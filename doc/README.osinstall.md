# Recipes for Installing Operating systems

## Installer and the "Recipe"

In a traditional manual install installer presents dozens of manual prompts
requiring text entry, selection from options and checking radio and check boxes
on text console based or graphical GUI during the installation.
The OS install recipe aims to provide the answers to most or all of the
questions and prompts presented by installer. By providing partial answers,
the installer will still pop up UI for the unanswered questions.
By providing all the answers, you can achieve a 100% unattended / automated install (which is very likely the
reason you want to use lineboot).

Some of the recipe provided hints and directives may not be solely answers
to installer questions, but be targeted for advanced customization of installation
(not only basic install information that installer prompts for).

In linetboot the OS install recipes are dynamically generated by templating using parameters from multiple sources:

- User: JSON file given by inst.userconfig (for initial non-root user to create on host)
- Network settings: Network settings from main config "net" section overriden by settings from recorded host facts
- Misc settings from main config "inst" (OS Installation) section: locatization, timezone, running post-install script
- Host Facts - If old configuration is good and working it will likely work for next install as well (If host config is bad,
  fix the host and re-extract facts with ansible - now you have good facts). Facts are an indispensible tool for (as an example)
  cases where net cable was (for some reason) attached to a very custom port, e.g. port 3 and for legacy reason
  (e.g. cabling is too tangled) you cannot fix it.

<!-- Illustrate host-recipe interaction -->

![Recipe Creation](doc/recipegen.png "Recipe Creation Illustrated")

### The subsystems configured by typical installer (and Lineboot)

Roughly in the order they are performed during install.
- Language, keyboard, time and localization
- Networking, setting up active network device/interface
- OS Package and Mirror package repository settings
- Partitioning and disks
- Installing extra packages
- Bootloader installation
- Running post-install scripts

## OS Install Pre and Post Operations

Installers and their recipe formats usually allow running a shell command (e.g. script) before the main installer runs and
also similarly running an executable after installer has completed it's work at the very end of the install.
These are called pre and post operartions (or scrips or hooks).

These customizable scripting solutions are a powerful mechanism to compensate for the shortcomings of installer out-of-box
functionality and bugs in it.

Because there is very little of anything on the host (besides Installer that just started to run) at the beginning of install
when pre-script runs, the post-install phase remains the more interesting one out of the two (e.g. you will have some tools
installed, by which you will get yor post install chores done).

Linetboot provides a few good out-of-the box postscripts preconfigured (as an exaple) in inst.postscrips config var.
See these usable example scripts in `scripts/` directory:

- os_fixup.sh - Fix misc shortcomings and bugs in OS install early phase (meant to be run early among postscripts)
- mv_homedir_for_autofs.sh - Move created user homedir so that using /home as empty mountpoint (for autofs/NFS) is possible
- nis_setup.sh - Setup and start NIS (relies on NIS config being present, see net.nis* config vars). By having NIS up already at
  first boot, the further "push" post provisioning may be much easier
- ssh_keys_setup.sh - Exchange (public) keys between OS install client and Lineboot so that Linetboot (SSH) host / user will
  have easy passwordless access (by e.g. plain SSH, SCP, rsync. ansible - all of which use SSH) to OS client from Lineboot host. 

## Triggering Custom Setup Steps on First Boot

![Post Install Flow](doc/postinstall.png "Post Install Flow Illustrated")

Linetboot is able to monitor the host after installation and detect when it's boot with newly installed operating system is completed.
This "Host-up" monitoring by Linetboot is based on SSH (and being able to automatically / programmatically log on to host).
On such "Host-up (with SSH)" event Linetboot allows one of 2 kinds of "executable hooks" to be run:

- JS/Node.js callback contained in custom setup module
- Any Shell executable (*.sh, *.py, *.pl, ELF binary, ...) named in main config `postinst.execact`

The shell executable (or JS plugin) can then use SSH (or some other SSH related methodology, such as rsync) to perform additional setup
steps on the host. See Post-Install illustration above to see the flow of events.

### Performing "root" Operations on Host

Almost all the post provisioning ops (e.g. tweak files in /etc/, install packages, launch dameons) must happen as root,
additionally when doing this remotely and in an automated context poses challenges on getting to "root state" to run
provisioning commands. Here are some suggestions.

- Use root@... user (directly) via SSH (requires SSH key copy)
- Use sudo command with normal user - with passwordless sudo authorization
- Run ansible ad-hoc commands or playbooks (as ansible is very good at switching to supervisory mode) 

### Environment variables set up for Post Install

The following environment variables are setup for Post Install shell command (postinst.js):

- POSTOP_IP: IP Address of Client host 
- POSTOP_USER: The username of Initial user 
- LINETBOOT_URL: The lineboot server http user (with port, without trailing slash)
- LINETBOOT_HOSTS_FILE: Linetboot hosts filename (as absolute path)

<!--
### Examples of JS callbacks and shell commands

-->
## Creating Recipes

Creating recipes for automated operating installation can be tedious,
especially if ignoring existing working examples (from internet, distro exaples) or relying too much on "just read the documentation". This is componded by:

- Recipe formats and directives changing with new versions of installers
- New directives getting introduced and deprecated quickly (making them only
work with narrow set of installer versions)
- Documentation being specific to one very particular version of installer and recipe format.
- Challenges debugging (esp. interactively) the recipe based problems and errors during installation
- Recipe formats not being accurately versioned and documented as declared working with particular version of installer
- Various bugs in (particular version) of installer

Suggestion from debian wiki to extract preseed config values (use selectively in preseed, not as-is):
```
# Install package containing debconf-get-selections
sudo apt install debconf-utils --no-install-recommends
# Extract config selections (Needs to run as sudo, try with and without --installer,
# produces different amount of info, e.g. 1342 vs. 435 lines respectively, latter has most lines "d-i" prefixed)
sudo debconf-get-selections --installer > someting_like_preseed.cfg
```
For any preseed file you can run a syntax check by: `debconf-get-selections -c preseed.cfg`

On Redhat/Centos you can generate kickstart file with graphical UI:
```
# Install
yum install system-config-kickstart
# Run
system-config-kickstart
```
You can also look for RH/Centos anakonda installer produced kickstart file `anaconda-ks.cfg` (/root/anaconda-ks.cfg).

Validating kickstart:
```
yum install pykickstart
ksvalidator /path/to/kickstart.ks
```
OpenSuSe / Yast:
```
# Creates autoinst.xml into location echoed in output
yast clone_system
```

### References
- https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax
- https://docs.centos.org/en-US/centos/install-guide/Kickstart2/

## Parametrizing Templated Recipes

The current Linetboot Templating engine of choice is Mustache, a logic-less templating engine (https://github.com/janl/mustache.js ).
Mustache works as an templating API and it aso has a command-line utility to fill-in templates with parameters being provided
by a JSON file.  
You will find plenty of examples in Linetboot `./tmpl/` subdirectory and from Mustache website. A few "in-a-nutshell" notes on Mustache:

- The template delimiters are `{{` and `}}` (`{{{` and '}}}' to prevent any default escapings, see further elaboration below)
- Fill in a simple var on top-level of params (member "httpurl"): `{{ httpurl }}` or one step from deeper from the structure by
  a "dot-notation" (sub-Object "net", member "ipaddr"): `{{ net.ipaddr }}`.
- Loop through an array of objects where objects have members "name" and "title":
  `{{#people}}- {{ name }} - {{ title }}\n{{/people}}` (In a file this should be split to multiple lines with no need for `\n`)
- Make a block of template output conditional (true/false evaluation of template var) on a value: `{{#hasloan}}Conditions of Loan: ...{{/hasloan}}`
- Avoid built-in (HTML geared) escaping rules from triggering by using 3 curlies: {{{ var\_with\_special\_chars\_in\_value }}}
  (This prevents e.g. '/' from becoming "&#x2F;")
- However never use triple-curlies in a loop or conditional construct (Mnemonic for this: These are not about escaping a
  string/scalar value)

With these simple rules - and especially by reading the full manual - you should be equipped to create correct working templates.
Logicless templating often shows its limitations in places where you'd want to e.g. join array values, etc (There's no operation "join"
in logicless templating). However limitations of "logicless" have been largely overcome sofar.

## Info on Template Parameters

During the OS Install Linetboot creates a comprehensive set of parameters based on:
- Global Main Configuration
- Individual host facts
- Inverntory host parameters (aka "host variables")
- Intial user info (from JSON file given by inst.userconfig)

The layout rules for parameter "tree" are:
- The global main config acts as as "base" for the parameter tree (The names/keys are by default as-is)
- The initial user properties are seen under top-level key "user" (names/keys as-is)
- The network information - that needs to be tailored for individual host (e.g. unique IP address) - is a mix of main
  config "environment specific" (not individual host) settings and individual host settings originated from facts
- Disk information gets created as "full disk recipe" on-the fly by linetboot so the names/keys are not appplicable here


Network settings formulation under key "net" (This is where most customization takes place):
- Names are close to ansible naming
- nameserver (array-of-str) - Arry of name server IP Addresses - Often hard to use on templates, thus string versions are provided
  - nameservers\_csv - Name servers as comma separated values (e.g. usable on RH kickstart)
  - nameservers\_ssv - Name servers ans space-separated values (e.g. usable on Preseed, ISC DHCP server)
  - nameservers\_str - Alias for nameservers
  - nameserver_first - First Nameserver for templates and apps where format only allows single name server
- gateway (str) - Gateway / Router IP Address
- netmask (str) - Netmask as dotted-quad
- domain (str) - Domain suffix (Empty string if there is no domain suffix)
- hostname (str) - short hostname (w/o domain suffix)
- ifnum (int) - Interface number (1-based value for the network interface order number, e.g. 1 could mean eno1, enp0s1)
- namesearch (array-of-str) - domain suffixes to try for DNS search by non-fqdn hostname searches

## Solution Hints for Recipe based Automation

- Use "stable" and long-time supported directives and constructs in your recipes
- Leave advanced customization parts of final installation to "post OS install" part of the installation
  - Run bare minimum customization as part of OS install (while still providing enough "answers" to keep install automated)
  - Run majority of customization in a post operation script (pre-script is too early to do this, e.g. network may not
    be up yet and filesystems may not yet be created)
  - Let installation finish, let the host reboot and run a remote (or local) provisioning operation
    (SSH commands, shell script, ansible, chef or puppet "play") to update and add configurations

## Setting Up The Network (by OS Installer)

Setting up network is challenging especially if your host during PXE (DHCP) phase does not get correct final network
information (e.g. correct IP address, correct gateway, netmask, etc). In case of getting wrong DHCP info, you should fix your DHCP
system first or have a serious discussion with DHCP provider to get it into shape.

Part of the solution to these problems is to have DHCP server always provide the correct, final network settings from
the very beginning of install. On static IP address machines this means associating the host MAC address to a fixed
IP address at the DHCP server (See Lineboot Configuration guide to see how to do this with various DHCP servers).

## Configuring the Disk Partitioning and Partition Allocation

Most installers in their recipe formats seem to be unable to configure existing partitions to be used for the installation because the situation where partitions are not laid like expected is difficult and awkward to handle
(Imagine a situation where first partition "sda1" is expected to be used as root partition, but it remains on disk as earlier boot partition making it way too small for purpose). For these reasons installers prefer "total control" over the disk and want the recipe
author to describe how all the OS used partitions are created from scratch.

The difficulty of this part is to come up with heuristics to size the partitions, especially when the hosts that you manage have different disk sizes. One hard-coded recipe will hardly work for this situation.

A "one-sizing-fits-all" solution for this is to configure the hard-wired disk layout in recipe with sizes fitting even the smallest disk of the host set. However this solution underutilizes the space on bigger disks and may not be satisfactory. Fixing the partition sizes - e.g. by re-sizing (typically growing) the partitons - after the OS install may be solution, but also leads to more scattered solution.

## Working with New Machines with no Facts

Linetboot allows new hosts with **No Ansible Facts** (a form of chicken-n-egg problem) to be declared in a small 3 column CSV file
given in main config as "customhosts". Do not use quotes or other fancy features of CSV dialects in this file. The properties
given in the file are:

- hname - Hostname (FQDN, e.g. test-001.mycorp.com)
- macaddr - MAC Address, lower case, ':' separating address octets (e.g. b0:26:30:f8:07:34)
- ipaddr - IP (v4) Address in standard "dotted quad" format (e.g. 192.168.1.115)

Example with 2 new hosts (Configured to be read in main config by e.g. `"customhosts": "~/newhosts.txt"`):
```
hname,macaddr,ipaddr
test-001.mycorp.com,b0:26:30:f8:07:34,192.168.1.115
test-002.mycorp.com,b0:26:30:f8:07:35,192.168.1.116
```
To use admin too newhostgen operation you *must* add (otherwise optional) column  "bmcipaddr":
```
hname,macaddr,ipaddr,bmcipaddr
test-001.mycorp.com,b0:26:30:f8:07:34,192.168.1.115,192.168.1.215
```
Note that the order of columns does not matter as long as the data matches headers.
Based this info lineboot will heuristically generate "fake-facts" for these hosts (based on e.g. global network info) and add these
in its internal (runtime) host lists, indexes, etc.
Note: These hosts should not be entered in the inventory "hosts" file.

In the web frontend the hosts will appear as normal hostviews, but with clearly lacking fact properties (esp. seen on
"Hardware" and "OS/Version" tabs). However the fake-facts generated heuristically should be enough to Boot Up Host (with e.g. Gparted) or  
Install an OS on them. After OS Install you can "properly" collect the facts for hosts and add them into your host inventory as permanent
hosts. Remember to disable the main config `"customhosts": "~/newhosts.txt"` after doing this.
You will usually create a new CSV file for each new batch of machines you will recieve into your IT/Engineering environment.
As such it might be a better convention to note that in name of CSV file, e.g. `newhosts_2020_Q4.txt`.
 

 

