# Recipes for Installing Operating systems

## Installer and the "Recipe"

In a traditional manual install installer presents dozens of manual prompts
requiring text entry, selection from options and checking radio and check boxes
on text console based or graphical GUI during the installation.
The OS install recipe aims to provide the answers to most or all of the
questions and prompts presented by installer. By providing partial answers,
the installer will still pop up UI for the unanswered questions.
By providing all the answers, you can achieve a 100% unattended / automated install (which is very likely the
reason you want to use lineboot).

Some of the recipe provided hints and directives may not be solely answers
to installer questions, but be targeted for advanced customization of installation
(not only basic install information that installer prompts for).

In linetboot the OS install recipes are dynamically generated by templating using parameters from multiple sources:

- User: JSON file given by inst.userconfig (for initial non-root user to create on host)
- Network settings: Network settings from main config "net" section overriden by settings from recorded host facts
- Misc settings from main config "inst" (OS Installation) section: locatization, timezone, running post-install script
- Host Facts - If old configuration is good and working it will likely work for next install as well (If host config is bad,
  fix the host and re-extract facts with ansible - now you have good facts). Facts are an indispensible tool for (as an example)
  cases where net cable was (for some reason) attached to a very custom port, e.g. port 3 and for legacy reason
  (e.g. cabling is too tangled) you cannot fix it.

<!-- Illustrate host-recipe interaction -->

![Recipe Creation](doc/recipegen.png "Recipe Creation Illustrated")


## Pre and Post Operations

Installers and their recipe formats usually allow running a script or any executable before the main installer runs and also similarly running an
executable after installer has completed it's job.
These are called pre and post operartions (or scrips or hooks).

These customizable scripting solutions are a powerful mechanism to compensate for the shortcomings of installer out-of-box
functionality and bugs in it.

Because there is very little of anything on the host (besides Installer that just started to run) at the beginning of install
when pre-script runs, the post-install phase remains the more interesting one (e.g. you will have some tools installed, by which
you will get yor post install chores done).

## Creating Recipes

Creating recipes for automated operating installation can be tedious,
especially if ignoring existing working examples (from internet, distro exaples) or relying too much on "just read the documentation". This is componded by:

- Recipe formats and directives changing with new versions of installers
- New directives getting introduced and deprecated quickly (making them only
work with narrow set of installer versions)
- Documentation being specific to one very particular version of installer and recipe format.
- Challenges debugging (esp. interactively) the recipe based problems and errors during installation
- Recipe formats not being accurately versioned and documented as declared working with particular version of installer
- Various bugs in (particular version) of installer

## Parametrizing Templated Recipes

The current Linetboot Templating engine of choice is Mustache, a logic-less templating engine (https://github.com/janl/mustache.js ).
Mustache works as an templating API and it aso has a command-line utility to fill-in templates with parameters being provided
by a JSON file.  
You will find plenty of exaples in Linetboot `./tmpl/` subdirectory and from Mustache website. A few "in-a-nutshell" notes on Mustache:

- The template delimiters are `{{` and `}}` (`{{{` and '}}}' to prevent any default escapings, see further elaboration below)
- Fill in a simple var on top-level of params (member "httpurl"): `{{ httpurl }}` or one step from deeper from the structure by
  a "dot-notation" (sub-Object "net", member "ipaddr"): `{{ net.ipaddr }}`.
- Loop through an array of objects where objects have members "name" and "title":
  `{{#people}}- {{ name }} - {{ title }}\n{{/people}}` (In a file this should be split to multiple lines with no need for `\n`)
- Make a block of template output conditional (true/false evaluation of template var) on a value: `{{#hasloan}}Conditions of Loan: ...{{/hasloan}}`
- Avoid built-in (HTML geared) escaping rules from triggering by using 3 curlies: {{{ var_with_special_chars_in_value }}}
- However never use triple-curlies in a loop or conditional construct (Mnemonic for this: These are not about escaping a
  string/scalar value) 

With these simple rules - and especially by reading the full manual - you should be equipped to create correct working templates.
Logicless templating often shows its limitations in places where you'd want to e.g. join array values, etc (There's no operation "join"
in logicless templating). However limitations of "logicless" have been largely overcome sofar.

## Solution Hints for Recipe based Automation

- Use "stable" and long-time supported directives and constructs in your recipes
- Leave advanced customization parts of final installation to "post OS install" part of the installation
  - Run bare minimum customization as part of OS install (while still providing enough "answers" to keep install automated)
  - Run majority of customization in a post operation script
  - Let installation finish, let the host reboot and run a remote (or local) provisioning operation
    (SSH commands, shell script, ansible, chef or puppet "play") to update and add configurations

## Setting Up The Network (by OS Installer)

Setting up network is challenging especially if your host during PXE (DHCP) phase does not get correct final network
information (e.g. correct IP address, correct gateway, netmask, etc). In case of getting wrong DHCP info, you should fix your DHCP
system first or have a serious discussion with DHCP provider to get it into shape.

Part of the solution to these problems is to have DHCP server always provide the correct, final network settings from
the very beginning of install. On static IP address machines this means associating the host MAC address to a fixed
IP address at the DHCP server (See Lineboot Configuration guide to see how to do this with various DHCP servers).

## Configuring the Disk Partitioning and Partition Allocation

Most installers in their recipe formats seem to be unable to configure existing partitions to be used for the installation because the situation where partitions are not laid like expected is difficult and awkward to handle
(Imagine a situation where first partition "sda1" is expected to be used as root partition, but it remains on disk as earlier boot partition making it way too small for purpose). For these reasons installers prefer "total control" over the disk and want the recipe
author to describe how all the OS used partitions are created from scratch.

The difficulty of this part is to come up with heuristics to size the partitions, especially when the hosts that you manage have different disk sizes. One hard-coded recipe will hardly work for this situation.

A "one-sizing-fits-all" solution for this is to configure the hard-wired disk layout in recipe with sizes fitting even the smallest disk of the host set. However this solution underutilizes the space on bigger disks and may not be satisfactory. Fixing the partition sizes - e.g. by re-sizing (typically growing) the partitons - after the OS install may be solution, but also leads to more scattered solution.

## Working with New Machines with no Facts

Linetboot allows new hosts with **No Ansible Facts** (a form of chicken-n-egg problem) to be declared in a small 3 column CSV file
given in main config as "customhosts". Do not use quotes or other fancy features of CSV dialects in this file. The properties
given in the file are:

- hname - Hostname (FQDN, e.g. test-001.mycorp.com)
- macaddr - MAC Address, lower case, ':' separating address octets (e.g. b0:26:30:f8:07:34)
- ipaddr - IP (v4) Address in standard "dotted quad" format (e.g. 192.168.1.115)

Example with 2 new hosts (Configured to be read in main config by e.g. `"customhosts": "~/newhosts.txt"`):
```
hname,macaddr,ipaddr
test-001.mycorp.com,b0:26:30:f8:07:34,192.168.1.115
test-002.mycorp.com,b0:26:30:f8:07:35,192.168.1.116
```
Based this info lineboot will heuristically generate "fake-facts" for these hosts (based on e.g. global network info) and add these
in its internal (runtime) host lists, indexes, etc.
Note: These hosts should not be entered in the inventory "hosts" file.

In the web frontend the hosts will appear as normal hostviews, but with clearly lacking fact properties (esp. seen on
"Hardware" and "OS/Version" tabs). However the fake-facts generated heuristically should be enough to Boot Up Host (with e.g. Gparted) or  
Install an OS on them. After OS Install you can "properly" collect the facts for hosts and add them into your host inventory as permanent
hosts. Remember to disable the main config `"customhosts": "~/newhosts.txt"` after doing this.
You will usually create a new CSV file for each new batch of machines you will recieve into your IT/Engineering environment.
As such it might be a better convention to note that in name of CSV file, e.g. `newhosts_2020_Q4.txt`.
 

 

